[{"content":"Sometimes we need to execute some long tasks at the backend, and the tasks are complicated and error-prone. So we hope users can see the real-time console log. Thus we need to redirect the stdout in our functions to the user\u0026rsquo;s browser.\nGiven a function like the following. How to see the stdout in real-time in the browser?\nimport time def job(times): for i in range(times): print(f\u0026#39;Task #{i}\u0026#39;) time.sleep(1) print(\u0026#39;Done\u0026#39;) time.sleep(0.5) Streaming Response Normally, responses are sent after all the data has been collected. However, sometimes we can\u0026rsquo;t wait until the data is prepared. In this case, we\u0026rsquo;ll use streaming response. In Django, it\u0026rsquo;s StreamingHttpResponse. I\u0026rsquo;ll call it SHR in the following article. StreamingHttpResponse accepts an iterator for input. It sends the value each time getting a new value from the iterator. To use it, we only need to implement an iterator function. It will send the value from yield  to the user\u0026rsquo;s browser in real-time.\n# Example of StreamingHttpResponse from django.http.response import StreamingHttpResponse def example(): for i in range(5): # Add \u0026lt;br\u0026gt; to break line in browser yield f\u0026#39;{i}\u0026lt;br\u0026gt;\u0026#39; def stream(request): return StreamingHttpResponse(example()) Output (in browser):\n0 1 2 3 4 Threading As we execute the task and stream output at the same time, we need concurrence. In Python, there are multiple choices, like threading, multiprocessing, etc. I\u0026rsquo;ll use threading in this article because it is easier for me.\n# Example of threading from threading import Thread import time def example(times): for i in range(times): print(i) time.sleep(1) # Create Thread thread = Thread(target=example, args=(5,)) # Start Thread thread.start() time.sleep(2) print(\u0026#34;This is printed in the main thread\u0026#34;) # Waiting thread to be done thread.join() Output:\n0 1 This is printed in the main thread 2 3 4 Redirect Stdout To change the location where Python print, we need to change sys. stdout. It accepts any File-like object. Specifically, we need to define an object with the write method.\n# Example of redirect stdout import sys class Printer: def __init__(self): self.contents = [] def write(self, value): self.contents.append(value) printer = Printer() sys.stdout = printer print(\u0026#39;This should be saved in printer\u0026#39;) sys.stdout = sys.__stdout__ print(\u0026#39;This should be printed to stdout\u0026#39;) print(printer.contents) Output:\nThis should be printed to stdout ['This should be saved in printer', '\\n'] Implement Redirecting Stdout to Streaming Response Environment Python 3.8.5\nDjango 3.2\nFirst, create Django Project\npip install django django-admin startproject console_streaming cd console_streaming python manage.py startapp web Install web\n# console_streaming/settings.py INSTALLED_APPS = [ ... # Add web \u0026#39;web\u0026#39;, ] Create a view\n# web/views.py def stream(request): # implement later pass Bind to URL\n# console_streaming/urls.py from django.urls import path from web import views urlpatterns = [ path(\u0026#39;stream/\u0026#39;, views.stream), ] Testing Task This is the testing function we\u0026rsquo;re going to use. It will repeat printing a line and waiting a second for n times, and then print \u0026ldquo;Done\u0026rdquo;.\n# web/views.py import time def job(times): for i in range(times): print(f\u0026#39;Task #{i}\u0026#39;) time.sleep(1) print(\u0026#39;Done\u0026#39;) time.sleep(0.5) Printer class We implement a Printer class to handle stdout, and we\u0026rsquo;ll only use one instance in the whale program life cycle. Because sys.stdout does not thread-specific, if we use different stdout in different requests, one would grab stdout from another. So I use a dictionary to store the queue for different threads, and use current_thread() to identify and pick the right queue. If the current thread hasn\u0026rsquo;t registered to Printer, use the default stdout.\n# web/views.py from queue import Queue from threading import current_thread import sys class Printer: def __init__(self): self.queues = {} def write(self, value): \u0026#39;\u0026#39;\u0026#39;handle stdout\u0026#39;\u0026#39;\u0026#39; queue = self.queues.get(current_thread().name) if queue: queue.put(value) else: sys.__stdout__.write(value) def flush(self): \u0026#39;\u0026#39;\u0026#39;Django would crash without this\u0026#39;\u0026#39;\u0026#39; pass def register(self, thread): \u0026#39;\u0026#39;\u0026#39;register a Thread\u0026#39;\u0026#39;\u0026#39; queue = Queue() self.queues[thread.name] = queue return queue def clean(self, thread): \u0026#39;\u0026#39;\u0026#39;delete a Thread\u0026#39;\u0026#39;\u0026#39; del self.queues[thread.name] # Initialize a Printer instance printer = Printer() sys.stdout = printer Streamer class Next, we\u0026rsquo;re going to implement concurrent execution and streaming response by a Streamer class. It will initialize a thread, and register it to the printer to get a queue. Then it repeats to read the value from queue and yield to response until the thread ends.\nfrom threading import Thread class Steamer: def __init__(self, target, args): self.thread = Thread(target=target, args=args) self.queue = printer.register(self.thread) def start(self): self.thread.start() print(\u0026#39;This should be stdout\u0026#39;) while self.thread.is_alive(): try: item = self.queue.get_nowait() yield f\u0026#39;{item}\u0026lt;br\u0026gt;\u0026#39; except Empty: pass yield \u0026#39;End\u0026#39; printer.clean(self.thread) def stream(request): streamer = Steamer(job, (10,)) return StreamingHttpResponse(streamer.start()) Run Django server\n$ python manage.py runserver Open http://localhost:8000/stream/\nThen you can see\nEach time you make a request, you can see one output in the terminal.\nThis should be stdout Full views.py from django.http.response import StreamingHttpResponse from queue import Queue, Empty from threading import Thread, current_thread import time import sys class Printer: def __init__(self): self.queues = {} def write(self, value): \u0026#39;\u0026#39;\u0026#39;handle stdout\u0026#39;\u0026#39;\u0026#39; queue = self.queues.get(current_thread().name) if queue: queue.put(value) else: sys.__stdout__.write(value) def flush(self): \u0026#39;\u0026#39;\u0026#39;Django would crash without this\u0026#39;\u0026#39;\u0026#39; pass def register(self, thread): \u0026#39;\u0026#39;\u0026#39;register a Thread\u0026#39;\u0026#39;\u0026#39; queue = Queue() self.queues[thread.name] = queue return queue def clean(self, thread): \u0026#39;\u0026#39;\u0026#39;delete a Thread\u0026#39;\u0026#39;\u0026#39; del self.queues[thread.name] printer = Printer() sys.stdout = printer class Steamer: def __init__(self, target, args): self.thread = Thread(target=target, args=args) self.queue = printer.register(self.thread) def start(self): self.thread.start() print(\u0026#39;This should be stdout\u0026#39;) while self.thread.is_alive(): try: item = self.queue.get_nowait() yield f\u0026#39;{item}\u0026lt;br\u0026gt;\u0026#39; except Empty: pass yield \u0026#39;End\u0026#39; printer.clean(self.thread) def job(times): for i in range(times): print(f\u0026#39;Task #{i}\u0026#39;) time.sleep(1) print(\u0026#39;Done\u0026#39;) time.sleep(0.5) def stream(request): streamer = Steamer(job, (10,)) return StreamingHttpResponse(streamer.start()) Complete code on GitHub\nReferences  Python Docs: threading Python Docs: queue Chase Seibert: Redirect console output to a Django HttpResponse thread specific sys.stdout? G. T. Wang: Python 多執行緒 threading 模組平行化程式設計教學  ","permalink":"https://wancat.cc/en/post/django-redirect-stdout-to-streaming/","summary":"Sometimes we need to execute some long tasks at the backend, and the tasks are complicated and error-prone. So we hope users can see the real-time console log. Thus we need to redirect the stdout in our functions to the user\u0026rsquo;s browser.\nGiven a function like the following. How to see the stdout in real-time in the browser?\nimport time def job(times): for i in range(times): print(f\u0026#39;Task #{i}\u0026#39;) time.sleep(1) print(\u0026#39;Done\u0026#39;) time.","title":"How to Redirect Stdout to Streaming Response in Django"},{"content":"我是 Wancat，就讀五專，從小六開始學習 Scratch，國二開始學習 Python。寫 Go、Python、JavaScript。 我喜歡寫程式、寫文章，從 2017 年 11 月開始經營 WANcatServer，在這裡與人分享我的想法。\n我愛玩 0 A.D.，喜歡推廣 Linux，支持自由軟體。\n我的連結  Matters GitHub email: wancat@wancat.cc  專案  FeverPass 體溫記錄系統 排列組合計算機 股票紅綠燈 Go 寫的股票爬蟲網站 Bitmark Issuer Bitmark 區塊鏈的發禮物系統 FireWheel 火輪手槍 使用 Python + Pygame 製作的原創遊戲 AddPoint 加分程式 老師上課的加分小幫手 P2P Talking 點對點聊天程式 (服務停止) 使用 Python 寫成的點對點通訊軟體 Huffman Coding 霍夫曼編碼器 霍夫曼演算法的實做  Skills  Golang Python JavaScript Linux Hosting  ","permalink":"https://wancat.cc/en/about/","summary":"我是 Wancat，就讀五專，從小六開始學習 Scratch，國二開始學習 Python。寫 Go、Python、JavaScript。 我喜歡寫程式、寫文章，從 2017 年 11 月開始經營 WANcatServer，在這裡與人分享我的想法。\n我愛玩 0 A.D.，喜歡推廣 Linux，支持自由軟體。\n我的連結  Matters GitHub email: wancat@wancat.cc  專案  FeverPass 體溫記錄系統 排列組合計算機 股票紅綠燈 Go 寫的股票爬蟲網站 Bitmark Issuer Bitmark 區塊鏈的發禮物系統 FireWheel 火輪手槍 使用 Python + Pygame 製作的原創遊戲 AddPoint 加分程式 老師上課的加分小幫手 P2P Talking 點對點聊天程式 (服務停止) 使用 Python 寫成的點對點通訊軟體 Huffman Coding 霍夫曼編碼器 霍夫曼演算法的實做  Skills  Golang Python JavaScript Linux Hosting  ","title":"About Me"}]